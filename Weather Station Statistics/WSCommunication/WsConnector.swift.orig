//
//  WsConnector.swift
//  Weather Station Statistics
//
//  Created by Yuval Weinstein on 03/03/2020.
//  Copyright Â© 2020 Yuval Weinstein. All rights reserved.
//

import Foundation
import Network

/// This class should be used to connect to the remote weather station.
///
/// In order to start the connection connect function should be invoked with the ip of the weather station or a broadcast ip.
///
/// The communication is done through requests fron host and responses from the weather station.
/// Please refer to the API in order to send requests to the weather station.
/// In order to get the responses from the weather station a response observer should be registered.
/// All response observers are notified when a new response arrives from the weather station.
///
class WsConnector {
    
    private var wsConnection: NWConnection?
    private var wsConnectionQueue: DispatchQueue
    
    private var connectionAvailableSemaphore: DispatchSemaphore
    private var readyToUseSemaphore: DispatchSemaphore
    
<<<<<<< HEAD
    private var responseObservers: [ResponseObserver]
=======
    private var messageObservers: [ResponseObserver]
>>>>>>> 84cdbae... Simplifying WSCommunication design
    private var connectionObservers: [ConnectionObserver]
    private var requestQuete: BlockingQueue<RequestProtocol>
        
    init() {
        self.wsConnectionQueue = DispatchQueue(label: "sendReceivesQueue", qos: .utility)
        
        self.readyToUseSemaphore = DispatchSemaphore(value: 0)
        self.connectionAvailableSemaphore = DispatchSemaphore(value: 0)

<<<<<<< HEAD
        self.responseObservers = Array<ResponseObserver>()
=======
        self.messageObservers = Array<ResponseObserver>()
>>>>>>> 84cdbae... Simplifying WSCommunication design
        self.connectionObservers = Array<ConnectionObserver>()
        self.requestQuete = BlockingQueue()
    }
    
    /// Establishes a connection with the remote weather station.
    /// - Parameter ip: The ip of the weather station or a broadcast ip.
    func connect(ip: String) {
        self.wsConnectionQueue.async {
            self.connectionObservers.forEach {$0.handleLookingForConnection()}
            self.setTcpServer()
            let wsFound = self.search(ip: ip, timeout: 10)
            
            if wsFound {
                self.readyToUseSemaphore.wait()
                self.connectionObservers.forEach {$0.handleFoundConnection()}
            } else {
                self.connectionObservers.forEach {$0.handleNotFoundConnection()}
            }
        }
    }
    
    /// Requests history annotations from the weather station.
    /// - Parameters:
    ///   - year: The year of the desired annotations.
    ///   - fromRecordNumber: The index of the first record to obtain.
    ///   - numberOfRecords: The number of records to obtain from the weather station.
    ///
    func requestHistoryData(year: Int, fromRecordNumber: Int, numberOfRecords: Int) {
        let maxRecordNumber = 1000
        for i in stride(from: fromRecordNumber, through: fromRecordNumber + numberOfRecords, by: maxRecordNumber) {
            let size = min(maxRecordNumber, fromRecordNumber + numberOfRecords - i)
            self.requestQuete.push(HistoryDataRequest(year: year, fromRecordNumber: i, numberOfRecords: size))
        }
    }
    
    /// Requests data regarding the history files available. Each file is identified by a certain year and it contains records from that year.
    func requestHistoryFiles() {
        self.requestQuete.push(HistoryFileRequest())
    }
    
    /// Requests data regarding the current weather conditions.
    func RequestNowRecord() {
         self.requestQuete.push(NowRecordRequest())
    }

    private func search(ip: String, timeout: Int) -> Bool {
        let udpConnection = NWConnection(host: NWEndpoint.Host(ip), port: 6000, using: .udp)
        let udpConnectionQueue = DispatchQueue(label: "udpQueue", qos: .utility)
        udpConnection.start(queue: udpConnectionQueue)
        let searchMessage = MessageHeader(title: "PC2000", mode: "SEARCH", identifier: "", size: 0)
        
        for _ in 0..<timeout {
            udpConnection.send(content: searchMessage.bytes, contentContext: .defaultMessage, isComplete: true, completion: NWConnection.SendCompletion.contentProcessed({ (error) in }))
            
            let dispatchTimeoutResult = self.connectionAvailableSemaphore.wait(timeout: DispatchTime.now().advanced(by: DispatchTimeInterval.seconds(1)))
            
            if dispatchTimeoutResult == .success {
                return true
            }
        }
        return false
    }
    
    private func receiveResponse() {
        let responseReceived = DispatchSemaphore(value: 0)
        self.wsConnection!.receiveMessage { (content, context, isComplete, error) in
            let messageParams = context?.protocolMetadata(definition: WSFramer.definition) as? NWProtocolFramer.Message
            let identifier = messageParams?.messageIdentifier
            
            if identifier == HistoryFileResponse.identifier {
                let response = HistoryFileResponse(data: content!)
                print(response.files)
<<<<<<< HEAD
                for observer in self.responseObservers {
=======
                for observer in self.messageObservers {
>>>>>>> 84cdbae... Simplifying WSCommunication design
                    DispatchQueue.main.async { 
                        observer.handle(response: response)
                    }
                }
            } else if identifier == HistoryDataResponse.identifier {
                let response = HistoryDataResponse(data: content!)
<<<<<<< HEAD
                for observer in self.responseObservers {
=======
                for observer in self.messageObservers {
>>>>>>> 84cdbae... Simplifying WSCommunication design
                    DispatchQueue.main.async {
                        observer.handle(response: response)
                    }
                }
            } else if identifier == NowRecordResponse.identifier {
                let response = NowRecordResponse(data: content!)
<<<<<<< HEAD
                for observer in self.responseObservers {
=======
                for observer in self.messageObservers {
>>>>>>> 84cdbae... Simplifying WSCommunication design
                    DispatchQueue.main.async {
                        observer.handle(response: response)
                    }
                }
            }
            responseReceived.signal()
        }
        responseReceived.wait()
    }
    
    private func processRequests() {
        self.wsConnectionQueue.async {
            while self.wsConnection?.state == NWConnection.State.ready {
                let request = self.requestQuete.pop()
                self.sendRequest(request: request)
                self.receiveResponse()
            }
        }
    }
    
    private func sendRequest(request: RequestProtocol) {
        let metadata = NWProtocolFramer.Message(identifier: type(of: request).identifier)
        let context = NWConnection.ContentContext(identifier: "Data", metadata: [metadata])
        guard let wsConnection = self.wsConnection else {
            return
        }
        
        wsConnection.send(content: request.bytes, contentContext: context, isComplete: true, completion: .contentProcessed({ (error) in
        }))
    }
            
    private func setTcpServer() {
        do {
            let tcpOptions = NWProtocolTCP.Options()
            tcpOptions.enableKeepalive = true
            tcpOptions.keepaliveIdle = 2
            
            let wsOptions = NWProtocolFramer.Options(definition: WSFramer.definition)
            
            let parameters = NWParameters(tls: nil, tcp: tcpOptions)
            
            parameters.includePeerToPeer = true
            
            parameters.defaultProtocolStack.applicationProtocols.insert(wsOptions, at: 0)
            
            let listener = try NWListener(using: parameters, on: 6500)
            listener.newConnectionLimit = 1
            listener.newConnectionHandler = self.newConnection
            listener.start(queue: DispatchQueue(label: "tcpQueue"))
            
        } catch {
            print("could not connect")
        }
    }
    
    private func newConnection(connection: NWConnection) {
        if self.wsConnection == nil {
            self.wsConnection = connection
            self.connectionAvailableSemaphore.signal()
            self.wsConnection?.stateUpdateHandler = {
                (state) in
                if state == .ready {
                    self.readyToUseSemaphore.signal()
                } else if state == .failed(NWError.posix(.ECONNRESET)) {
                    self.wsConnection?.cancel()
                    self.connectionObservers.forEach {$0.handleConnectionStopped()}
                }
            }
            self.wsConnection?.start(queue: DispatchQueue(label: "connectionQueue"))
            self.processRequests()
        }
    }
        
<<<<<<< HEAD
    func assignResponseObserver(observer: ResponseObserver) {
        self.responseObservers.append(observer)
    }
    
    func assignConnectionObserver(observer: ConnectionObserver) {
        self.connectionObservers.append(observer)
    }
    
    func removeResponseObserver(observer: ResponseObserver) {
        self.responseObservers.remove(at: self.responseObservers.index(after: -1))
    }
    
    func removeConnectionObserver(observer: ConnectionObserver) {
=======
    func assignObserver(observer: ResponseObserver) {
        self.messageObservers.append(observer)
    }
    
    func assignObserver(observer: ConnectionObserver) {
        self.connectionObservers.append(observer)
    }
    
    func removeObserver(observer: ResponseObserver) {
        self.messageObservers.remove(at: self.messageObservers.index(after: -1))
    }
    
    func removeObserver(observer: ConnectionObserver) {
>>>>>>> 84cdbae... Simplifying WSCommunication design
        self.connectionObservers.remove(at: self.connectionObservers.index(after: -1))
    }
}
